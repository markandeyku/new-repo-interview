1Ô∏è‚É£ How do you implement inter-service communication securely? (mTLS, JWT, OAuth2)

    mTLS (Mutual TLS):
    Both client and server present certificates ‚Üí ensures mutual authentication.
    Example: Service A calls Service B, both verify each other‚Äôs identities using X.509 certificates.
    üîë Best for internal service-to-service security inside Kubernetes or service mesh (Istio, Linkerd).

    JWT (JSON Web Token):
    Each request carries a signed token with claims (user id, roles, expiry).
    Services validate JWT using a shared secret or public key.
    üîë Lightweight, stateless, commonly used for user-to-service communication.

    OAuth2:
    Delegated authorization mechanism.
    Example: A Payment Service can access a User‚Äôs bank account on their behalf, without storing credentials.
    üîë Best for user identity delegation (login via Google, Facebook).

    üëâ Interview Tip: ‚ÄúFor internal service-to-service communication I‚Äôd use mTLS with a service mesh,
       and for user authentication I‚Äôd use OAuth2 + JWT.‚Äù


2Ô∏è‚É£ What is idempotency and how do you design idempotent APIs?
Definition: An operation is idempotent if calling it multiple times has the same effect as calling it once.
Why important in microservices?
    Network retries may cause duplicate requests. If not idempotent ‚Üí double billing, double booking.

Design strategies:

Use idempotency keys (e.g., X-Idempotency-Key header in payment APIs).
    For PUT requests ‚Üí replace resource instead of updating multiple times.
    For DELETE ‚Üí deleting the same resource twice should not fail.
    Store processed requests in DB/cache to reject duplicates.
    üëâ Example: Stripe‚Äôs API uses Idempotency-Key to ensure multiple retries of a payment don‚Äôt charge the customer twice.



3Ô∏è‚É£ How does a Circuit Breaker work?
Problem: If Service A calls Service B (which is slow/down), A may get stuck ‚Üí cascading failures.
Solution (Circuit Breaker):

    Closed state: Calls flow normally.
    Open state:   After N failures, breaker ‚Äúopens‚Äù ‚Üí requests fail immediately without hitting Service B.
    Half-open state: After a cooldown, allow a few trial requests ‚Üí if success ‚Üí close again.

Implementation: Resilience4j (Java), Envoy/Istio (infra).
üëâ Example: If Payment Service is down, Order Service will ‚Äúopen circuit‚Äù and fail fast ‚Üí user sees ‚ÄúPayment unavailable‚Äù instead of long timeout.

4Ô∏è‚É£ How do you handle partial failures in distributed systems?
    Retries with backoff: Retry failed requests, but with exponential backoff to avoid overload.
    Timeouts: Don‚Äôt wait indefinitely for a response.
    Fallbacks: Provide degraded functionality (e.g., show cached data if real-time data unavailable).
    Bulkhead pattern: Isolate resources so one failing service doesn‚Äôt consume all threads.
    Circuit Breaker: Prevent cascading failures.
    Compensating transactions: In workflows (Saga pattern), undo successful steps if one fails.

    üëâ Example: If Payment succeeds but Shipping fails ‚Üí Saga compensates by refunding the payment.

5Ô∏è‚É£ What is a Dead Letter Queue in messaging systems?

    Definition: A DLQ is a special queue where failed messages are sent after retry attempts are exhausted.
    Purpose:
    Prevents message loss.
    Allows debugging & reprocessing.
    Example: In Kafka or RabbitMQ, if a message keeps failing due to malformed payload ‚Üí it is moved to DLQ.

    üëâ Interview line: ‚ÄúDLQs help maintain resilience by ensuring no message is lost, while isolating bad events for analysis.‚Äù

6Ô∏è‚É£ Difference between Authentication and Authorization

    --- Authentication (Who are you?)
    Verifying identity.
    Example: Login with username/password, token validation.
    --- Authorization (What are you allowed to do?)
    Permission check.

    Example: User may be authenticated but not authorized to access /admin.
    üëâ AuthN before AuthZ: First prove identity ‚Üí then check access rights.


7Ô∏è‚É£ How do you implement JWT-based authentication in microservices?
 Flow:
     User logs in ‚Üí Auth Service issues JWT (signed with private key).
     User calls Service A ‚Üí includes JWT in Authorization: Bearer <token>.
     Service A validates JWT (using public key) ‚Üí extracts claims.
     No need to contact Auth Service again (stateless).

 Best Practices:
     Use short expiry + refresh tokens.
     Sign with asymmetric keys (RS256).
     Store minimal claims (userId, roles).

 üëâ Example: In Spring Boot, use spring-boot-starter-oauth2-resource-server to validate JWT automatically.

8Ô∏è‚É£ How do you secure internal microservice communication?
    mTLS (Mutual TLS): Ensure only trusted services communicate.
    Service Mesh (Istio/Linkerd): Handles encryption, auth, retries at infra level.
    API Gateway: Entry point to enforce authentication/authorization.
    Network Segmentation: Run services in a private network (VPC).
    üëâ Example: In Kubernetes, Istio enforces mTLS between pods ‚Üí no service can impersonate another.

9Ô∏è‚É£ Explain OAuth2 roles: Resource Owner, Client, Resource Server, Authorization Server
    Resource Owner: The user who owns the data.
    Client: Application requesting access (e.g., a mobile app).
    Resource Server: The API hosting the resource (e.g., Google Drive API).
    Authorization Server: Issues access tokens (e.g., Google‚Äôs OAuth server).
    üëâ Example: When you log into an app using Google Login:
    You (user) = Resource Owner
    The app = Client
    Google Drive API = Resource Server
    Google Auth server = Authorization Server

üîü How do you trace a request across multiple microservices?
    Use Distributed Tracing with correlation IDs.
    Each request carries a traceId + spanId across services.
    Tools:
    Spring Cloud Sleuth (adds IDs to logs automatically).
    Zipkin/Jaeger (visualize trace timelines).
    üëâ Example: User request ‚Üí API Gateway ‚Üí Order Service ‚Üí Payment Service ‚Üí Shipping Service ‚Üí trace visible end-to-end in Jaeger.

1Ô∏è‚É£1Ô∏è‚É£ Difference between Logging, Monitoring, and Tracing
    Logging: Capturing application logs for debugging. (e.g., Logback, ELK stack)

    Monitoring: Collecting system metrics (CPU, latency, errors) ‚Üí alerting. (Prometheus)

    Tracing: Tracking request flows across services. (Jaeger, Zipkin)

    üëâ ‚ÄúLogs = What happened, Monitoring = How healthy, Tracing = Where it went.‚Äù

1Ô∏è‚É£2Ô∏è‚É£ What‚Äôs the role of Prometheus & Grafana in microservices?
    Prometheus: Metrics collection (time-series DB). Scrapes metrics like CPU, memory, request latency.
    Grafana: Visualization/dashboard built on top of Prometheus metrics.
    üëâ Example: Prometheus collects request latency of Order Service, Grafana shows spike at 9PM (high traffic).

1Ô∏è‚É£3Ô∏è‚É£ What is eventual consistency? Give a real-world example.

    Definition: System guarantees data will become consistent across services eventually, not immediately.
    Why? Strong consistency (2PC) hurts availability in distributed systems.
    Real-world Example:
    In an e-commerce system, after placing an order ‚Üí Order Service marks it as "PLACED".
    Inventory & Payment update asynchronously.
    For a short time, UI may show stale stock count.
    Eventually, stock & payment status synchronize.
    üëâ Interview-safe analogy: ‚ÄúLike WhatsApp messages ‚Äì sender sees a single tick (sent), then later double
    tick (delivered). It‚Äôs eventually consistent.‚Äù



üîí Comparison Table: OAuth2.0 vs JWT vs Certificate-based vs Credential-based

| Aspect          | **OAuth 2.0**                                                             | **JWT (JSON Web Token)**                                        | **Certificate-based (mTLS)**                          | **Credential-based (Username/Password)**                              |
| --------------- | ------------------------------------------------------------------------- | --------------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------------------------------- |
| **Purpose**     | Authorization framework for delegated access                              | Token format for stateless authentication & authorization       | Authenticate both client & server at transport layer  | Basic authentication for identity verification                        |
| **Type**        | Authorization protocol                                                    | Token-based authentication                                      | Mutual authentication (TLS/SSL)                       | Direct authentication                                                 |
| **Use Case**    | Third-party access without sharing passwords (login via Google, Facebook) | Carry user claims across services, verify identity              | Secure service-to-service communication               | Login to system via username/password                                 |
| **Security**    | Requires HTTPS, tokens expire, supports scopes & refresh tokens           | Signed & optionally encrypted, prevents tampering               | Very strong (based on PKI), prevents impersonation    | Weak if passwords not hashed or rotated; vulnerable to replay attacks |
| **State**       | Can be stateless or stateful depending on implementation                  | Stateless (self-contained token)                                | Stateless for transport layer; depends on TLS session | State may be needed to track sessions                                 |
| **Complexity**  | High (requires authorization server, token management)                    | Medium (token signing/validation)                               | High (PKI infrastructure, certificate management)     | Low (simple to implement)                                             |
| **Revocation**  | Supported via token revocation, refresh token expiry                      | Difficult to revoke before expiry unless stored in DB/blacklist | Managed via certificate revocation list (CRL)         | Password change or account disable                                    |
| **Scalability** | High (supports distributed systems, microservices)                        | High (stateless, can scale horizontally)                        | Moderate (depends on certificate infrastructure)      | Limited (server needs to validate credentials each time)              |
| **Performance** | Slight overhead due to token issuance & validation                        | Very fast (local validation of token signature)                 | Medium (TLS handshake adds latency)                   | Fast but repeated password validation may hit DB                      |



Security related annotations and methods to secure the rest apis:

| Annotation                  | Purpose                          | Example Use Case                        |
| --------------------------- | -------------------------------- | --------------------------------------- |
| @EnableWebSecurity          | Enable web security              | Config class                            |

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    // configure authentication & authorization
}


| @EnableGlobalMethodSecurity | Enable method-level security     | pre/post authorization                  |

@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
}


| @Secured                    | Role-based method access         | Admin-only methods                      |

@Secured("ROLE_ADMIN")
public void deleteUser(Long userId) {
    // only users with ROLE_ADMIN can access
}

| @RolesAllowed               | JSR-250 version of @Secured      | Standard role check                     |

@RolesAllowed({"ROLE_ADMIN"})
public void createUser(User user) {
}

| @PreAuthorize               | Pre-invocation access control    | SpEL-based dynamic checks               |

    @PreAuthorize("hasRole('ADMIN')")
    public void updateUser(User user) { }

    @PreAuthorize("#user.id == authentication.principal.id")
    public void updateOwnProfile(User user) { }


| @PostAuthorize              | Post-invocation access control   | Check ownership of returned object      |

    @PostAuthorize("returnObject.owner == authentication.name")
    public User getUser(Long userId) {
        return userRepository.findById(userId);
    }


| @AuthenticationPrincipal    | Inject authenticated user        | Controller methods                      |

    @GetMapping("/profile")
    public UserProfile getProfile(@AuthenticationPrincipal UserDetails userDetails) {
        return userService.getProfile(userDetails.getUsername());
    }


| @PreFilter                  | Filter collections before method | Filter input list based on roles        |

@PreFilter("filterObject.owner == authentication.name")
public void processOrders(List<Order> orders) { }

| @PostFilter                 | Filter collections after method  | Filter returned list based on ownership |

@PostFilter("filterObject.owner == authentication.name")
public List<Order> getOrders() {
    return orderRepository.findAll();
}

